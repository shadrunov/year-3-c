\section{Задание на практическую работу}
Скомпилировать программу на языке C. Дизассемблировать полученный исполняемый файл с помощью \texttt{x64dbg}. Проследить за работой программы с помощью отладчика и Process Monitor и Process Hacker.



\section{Ход работы}

\subsection{Выделение памяти с помощью malloc в main}

Установим точку прерывания на месте последнего вызова функции перед завершением программы (\texttt{cexit}). Этот вызов соответствует функции \texttt{main} (Рисунок 1). 
\image{11.png}{Последний вызов перед выходом}{1}

После перехода по адресу функции мы видим два вызова (соответствуют функциям \texttt{printf} в исходном файле), инициализацию переменных и функции выделения памяти \texttt{malloc} (Рисунок 2). Выделяется память под переменную \texttt{buf} (куда попадают вводимые данные с консоли) и переменную \texttt{command} (первое слово из \texttt{buf}).
\image{12.png}{Выделение памяти с помощью \texttt{malloc}}{1}

После вызова \texttt{malloc} в регистр EAX сохраняется адрес выделенной ячейки памяти. На рисунке 3 видно, что этот участок памяти заполнен случайными значениями.
\image{13.png}{Memory dump}{1}
\FloatBarrier


\subsection{Обработка команды в fgets}
В консоль введём слово \texttt{open} для открытия файла. На рисунке 4 видно, что введённое значение было записано в ячейку памяти.

\image{21.png}{Содержимое памяти}{1}
\FloatBarrier


\subsection{Вызов API-функции CreateFile}
Далее вызывается функция \texttt{CreateFileA}. На рисунке 5 приведён нужный фрагмент библиотеки \texttt{kernel32.dll}.
\image{31.png}{Остановка на функции CreateFileA}{1}

На рисунке 6 видно, что в стеке сохранены аргументы функции, например, название файла (\texttt{AlekseyShadrunov.txt}). 
\image{32.png}{Стек}{1}

После вызова API-функции \texttt{CreateFileA} можно увидеть, что в EAX записано
значение \texttt{0xE0}. Это файловый дескриптор или хэндл открытого файла (Рисунок 7). 
\image{34.png}{Хэндл открытого файла}{1}

Этот же хэндл можно пронаблюдать в Process Hacker (Рисунок 8). 
\image{35.png}{Хэндл в Process Hacker}{1}
\FloatBarrier



\subsection{Вызов API-функции WriteFile}
Вводим в консоль команду \texttt{write} для записи строки в файл. На рисунке 9 показано состояние системы перед вызовом функции \texttt{WriteFile}. Все аргументы записаны в стек: хэндл файла (104), буфер со строкой, количество байт для записи (0xC, то есть 13) и ещё два аргумента. 
\image{44.png}{Аргументы в стеке}{1}

На рисунке 10 видно тело функции \texttt{WriteFile}, а также строка для записи, которая находится в дампе памяти. На рисунке 11 — возвращаемое значение 1 (в регистре EAX), что соответствует успешному выполнению функции.
\image{42.png}{Дамп памяти со строкой}{1}
\image{43.png}{Возвращаемое значение 1}{1}
\FloatBarrier


\subsection{Вызов API-функции ReadFile}
Далее считываем из файла с помощью функции \texttt{ReadFile}. Аргументы функции: хэндл (0x100), адрес выходного буфера (0xDC0F60), количество байт для чтения (0xC) и ещё два опциональных аргумента (Рисунок 12). Аргументы записываются в стек перед вызовом функции.
\image{51.png}{Аргументы в стеке}{1}

После вызова функции по адресу выходного буфера содержится строка из файла (Рисунок 13)
\image{53.png}{Строка в памяти}{1}
\FloatBarrier



\subsection{Добавить аргументы к командам}
С помощью ввода в консоль реализовано использование аргументов для задания параметров программы. Для открытия файлов можно задать имя файла, для записи можно задать хэндл и записываемое значение, для чтения можно задать хэндл, для закрытия — тоже хэндл. Для удобства работы пользователя хэндл выводится и вводится в виде десятичного числа. Примеры работы программы представлены на рисунках 14-18. Листинг кода содержится в приложении A. 

\image{61.png}{Открытие файла: вводим название файла, получаем хэндл в виде числа (252)}{0.8}
\image{62.png}{Этот хэндл в Process Hacker (0xFC = 252)}{1}
\image{63.png}{Команда \texttt{запись}: вводим хэндл файла, значение для записи}{0.8}
\image{64.png}{Команда \texttt{чтение}: вводим хэндл файла, программа выводит содержимое}{0.8}
\image{65.png}{Команда \texttt{закрыть}: видно, что хэндл исчез из Process Hacker}{1}
\FloatBarrier


\subsection{Найти утечку ресурсов в программе}
Утечка памяти в исходном файле связана с тем, как обрабатываются хэндлеры открытого файла. Видно, что для хранения хэндла используется переменная \texttt{HANDLE hFile}, которая создаётся при запуске программы. Далее при вводе команды \texttt{открыть} в эту переменную присваивается хэндл на открытый файл. Если ввести команду \texttt{открыть} ещё раз, то предыдущее значение хэндла будет перезаписано. Это значит, что закрыть предыдущий хэндл и освободить память невозможно. 

Есть несколько путей исправления этой утечки: можно создать массив хэндлов и записывать каждый следующий файл в массив, можно закрывать старый файл перед открытием нового файла. Наконец, можно запрещать открытие файла, если хэндл уже определён (и файл уже открыт). Реализация этого способа приведена на листинге 1. Результат работы программы — на рисунке 19.

\begin{lstlisting}[language=c, numbers=none, caption={Фрагмент функции main}]
else if ( strncasecmp(command, "open", strlen(command)) == 0 )
{
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        ret = LabOpenFile(chFileName, &hFile, &len);
    } 
    else 
    {
        printf("handle already defined. can't open file again! \n");
    }
}
\end{lstlisting}

\image{71.png}{Повторная команда открыть не работает}{1}
\FloatBarrier



\clearpage






\clearpage



\section{Выводы о проделанной работе}
В рамках данной работы получены знания: о принципах работы ЭВМ, об особенностях архитектуры компьютера фон Неймана и x86/x64 и о работе с объектами в ОС Windows.
В рамках данной работы получены навыки: анализ программ с использованием отладчика уровня ассемблера и отладка и поиск проблем с использованием средств Sysinternals.