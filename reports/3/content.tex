\section{Задание на практическую работу}
Скомпилировать программу на языке C. Дизассемблировать полученный исполняемый файл с помощью x64dbg. Проследить за работой программы с помощью отладчика и Process Monitor и Process Hacker.



\section{Ход работы}

\subsection{Выделение памяти с помощью malloc в main}

Установим точку прерывания на месте последнего вызова функции перед завершением программы (cexit). Этот вызов соответствует функции main (Рисунок 1). 
\image{11.png}{Последний вызов перед выходом}{1}

После перехода по адресу функции мы видим два вызова (соответствуют функциям printf в исходном файле), инициализацию переменных и функции выделения памяти malloc (Рисунок 2). Выделяется память под переменную buf (куда попадают вводимые данные с консоли) и переменную command (первое слово из buf).
\image{12.png}{Выделение памяти с помощью malloc}{1}

После вызова malloc в регистр EAX сохраняется адрес выделенной ячейки памяти. На рисунке 3 видно, что этот участок памяти заполнен случайными значениями.
\image{13.png}{Memory dump}{1}
\FloatBarrier


\subsection{Обработка команды в fgets}
В консоль введём слово open для открытия файла. На рисунке 4 видно, что введённое значение было записано в ячейку памяти.

\image{21.png}{Содержимое памяти}{1}
\FloatBarrier


\subsection{Вызов API-функции CreateFile}
Далее вызывается функция CreateFileA. На рисунке 5 приведён нужный фрагмент библиотеки kernel32.dll.
\image{31.png}{Остановка на функции CreateFileA}{1}

На рисунке 6 видно, что в стеке сохранены аргументы функции, например, название файла (AlekseyShadrunov.txt). 
\image{32.png}{Стек}{1}

После вызова API-функции CreateFileA можно увидеть, что в EAX записано
значение 0xE0. Это файловый дескриптор или хэндл открытого файла (Рисунок 7). 
\image{34.png}{Хэндл открытого файла}{1}

Этот же хэндл можно пронаблюдать в Process Hacker (Рисунок 8). 
\image{35.png}{Хэндл в Process Hacker}{1}
\FloatBarrier



\subsection{Вызов API-функции WriteFile}
Вводим в консоль команду write для записи строки в файл. На рисунке 9 показано состояние системы перед вызовом функции WriteFile. Все аргументы записаны в стек: хэндл файла (104), буфер со строкой, количество байт для записи (0xC, то есть 13) и ещё два аргумента. 
\image{44.png}{Аргументы в стеке}{1}

На рисунке 10 видно тело функции WriteFile, а также строка для записи, которая находится в дампе памяти. На рисунке 11 — Возвращаемое значение 1 (в регистре EAX), что соответствует успешному выполнению функции.
\image{42.png}{Дамп памяти со строкой}{1}
\image{43.png}{Возвращаемое значение 1}{1}
\FloatBarrier


\subsection{Вызов API-функции ReadFile}
Далее считываем из файла с помощью функции ReadFile. Аргументы функции: хэндл (0x100), адрес выходного буфера (0xDC0F60), количество байт для чтения (0xC) и ещё два опциональных аргумента (Рисунок 12). Аргументы записываются в стек перед вызовом функции.
\image{51.png}{Аргументы в стеке}{1}

После вызова функции по адресу выходного буфера содержится строка из файла (Рисунок 13)
\image{53.png}{Строка в памяти}{1}
\FloatBarrier


\subsection{Найти утечку ресурсов в программе}


\clearpage






\clearpage



\section{Выводы о проделанной работе}
В ходе работы я реализовал программу, подсчитывающую сумму остатков от деления на 3 элементов массива длиной 10. Программа написана на ассемблере. В программе используется синтаксис Intel, а также реализован вывод в консоль без подключения библиотек.