\section{Цель работы}
В файле записан ряд целых чисел, разделённых пробелом. Программа должна считать имя файла из первого аргумента командной строки и рассчитать сумму квадратов записанных в файл чисел. Для расчёта суммы квадратов программа должна создать N дочерних процессов (N передаётся вторым аргументом командной строки) и передать каждому из них часть полученных чисел. Каждый из дочерних процессов должен рассчитать сумму квадратов переданных ему чисел и вернуть её родительскому. Родительский процесс должен просуммировать полученные от дочерних числа и вывести на консоль итоговую сумму. Если исходный файл не существует, или в нём записано менее 2 чисел, следует вывести соответствующее сообщение для пользователя и завершить работу программы. 


\section{Ход работы}

\subsection{Описание алгоритма}
\subsubsection{Основной процесс}

Работа основной программы (main) состоит из нескольких этапов:
\begin{enumerate}
    \item Проверить количество входных аргументов. Если их не два, вывести подсказку.
    \item Сохранить аргументы в переменные input\_path (путь к файлу) и N (число байт).
    \item Вывести полученные параметры в консоль (функция printf).
    \item Открыть файл на чтение. Если открыть не удалось (не существует файла), вывести сообщение об ошибке.
    \item Считать файл слово за словом, считая количество входных чисел M (для чтения используем небольшой буфер и функцию fscanf). Полученное количество вывести на экран.
    \item Если количество меньше 2, вывести сообщение об ошибке.
    \item Если количество подпроцессов N больше M / 2, уменьшить N до M / 2.
    \item Вычислить количество данных для каждого подпроцесса ($M / N$ для всех, кроме последнего, и $n + M \% N$ для последнего), вывести на экран.
    \item Для каждого подпроцесса в цикле:
    \begin{itemize}
        \item Составить имя выходного файла (куда записывается часть входных данных) как \texttt{"\_\%d\_input.txt"}, где \texttt{\%d} — номер итерации цикла.
        \item Открыть файл на запись.
        \item Записать нужное количество элементов входных данных в файл и закрыть файл.
        \item Создать копию текущего процесса (fork).
        \item Заменить подпроцесс на программу calc, в качестве аргументов передать файл с частью входных данных и его размер.
    \end{itemize}
    \item Закрыть входной файл. Приостановить программу для принудительного ожидания подпроцессов (демонстрация процессов-зомби).
    \item Для каждого подпроцесса в цикле:
    \begin{itemize}
        \item Ожидать завершения (wait).
        \item Составить имя файла с результатом работы процесса (\texttt{"\_\%d\_result.txt"}, где \texttt{\%d} — PID завершённого процесса).
        \item Открыть файл на чтение, считать строку, увеличить сумму на число в строке, закрыть файл.
    \end{itemize}
    \item Распечатать результат.
\end{enumerate}


\subsubsection{Вспомогательный процесс}

Работа подпрограммы (calc) также состоит из нескольких этапов:
\begin{enumerate}
    \item Распечатать PID подпроцесса.
    \item Проверить количество входных аргументов. Если их не два, вывести подсказку.
    \item Сохранить аргументы в переменные input\_path (путь к файлу) и n (размер входной последовательности).
    \item Вывести полученные параметры в консоль (функция printf; для удобства к выводу подпроцессов добавляется PID).
    \item Открыть файл на чтение. Если открыть не удалось (не существует файла), вывести сообщение об ошибке.
    \item В цикле считывать числа из файла, возводить в квадрат и прибавлять к сумме. 
    \item Закрыть входной файл.
    \item Составить имя файла с результатом работы процесса (\texttt{"\_\%d\_result.txt"}, где \texttt{\%d} — PID завершённого процесса).
    \item Открыть файл на запись, записать результат, закрыть файл.
    \item Распечатать результат.
    \item Приостановить процесс на 5 секунд, затем завершить с кодом \texttt{EXIT\_SUCCESS}.
\end{enumerate}


Программа использует C Standart Library для работы с файлами и OS API для работы с процессами, поэтому эта часть отличается для Linux и Windows.

\subsection{Компилятор gcc}

При использовании компилятора gcc на Linux мы пользуемся системными вызовами из файла unistd.h и wait.h: fork и wait. Они используются для работы с подпроцессами. Исходный код программы для Linux приведён в приложении.

Для сборки основной программы используется команда: \texttt{gcc main.c -o main}. Для сборки вспомогательной программы используется команда: \texttt{gcc calc.c -o calc}. Процесс сборки показан на рисунке 1.

\image{11.png}{Сборка файлов}{0.7}
\FloatBarrier

Далее продемонстрируем работу программы (рисунки 2-5).

\image{12.png}{Неверные аргументы}{0.7}
\image{13.png}{Входной файл не существует}{0.7}
\image{14.png}{Входной файл пустой}{0.7}
\image{15.png}{Работа программы}{1}
\FloatBarrier

Процессы отображаются в htop (рисунки 6-7). Зомби-процессы появляются, когда родительский процесс ещё не вызвал wait.

\image{16.png}{Подпроцессы}{1}
\image{17.png}{Процессы-зомби}{1}
\FloatBarrier
\clearpage


\subsection{Компилятор MSVC}

Чтобы запустить эту программу на Windows, нужно заменить системные вызовы на WinAPI. Для этого подключаем файл Windows.h и используем функции GetStartupInfo, CreateProcess, WaitForSingleObject. Исходный код программы для Linux приведён в приложении.

Для компиляции и сборки программы используем Developer Command Prompt и команды: \texttt{cl calc.c /link /out:calc} и \texttt{cl main.c /link /out:main.exe}

Процесс сборки показан на рисунке 8.

\image{21.png}{Сборка файлов}{1}
\FloatBarrier

Далее продемонстрируем работу программы (рисунки 9-11).

\image{22.png}{Неверные аргументы}{0.6}
\image{23.png}{Входной файл не существует}{0.6}
\image{24.png}{Работа программы}{0.86}
\FloatBarrier

Процессы отображаются в Process Hacker (рисунки 12-13).

\image{25.png}{Подпроцессы}{0.9}
\image{26.png}{Основной процесс}{0.9}
\FloatBarrier
\clearpage


\subsection{Python}

Аналогичный функционал присутствует в языке Python. Код программы на Python приведён в приложении. 

Компиляция не предусмотрена и запуск осуществляется командой: \texttt{python main.py input.txt 3}.

Продемонстрируем работу программы (рисунки 14-5).

\image{31.png}{Неверные аргументы}{0.7}
\image{32.png}{Входной файл не существует}{0.7}
\image{33.png}{Работа программы}{0.86}
\FloatBarrier

Процессы отображаются в htop (рисунки 12-13).

\image{34.png}{Подпроцессы}{1}
\image{35.png}{Процессы-зомби}{1}
\FloatBarrier
\clearpage

\section{Выводы о проделанной работе}
В рамках данной работы я написал программу, которая считывает имя файла из первого аргумента командной строки и рассчитывает сумму квадратов записанных в файл чисел. Для расчёта суммы квадратов программа должна создать N дочерних процессов (N передаётся вторым аргументом командной строки) и передать каждому из них часть полученных чисел. Каждый из дочерних процессов должен рассчитать сумму квадратов переданных ему чисел и вернуть её родительскому. Родительский процесс должен просуммировать полученные от дочерних числа и вывести на консоль итоговую сумму. Если исходный файл не существует, или в нём записано менее 2 чисел, следует вывести соответствующее сообщение для пользователя и завершить работу программы. Скомпилировал программу с помощью компиляторов gcc и MSVC, а также реализовал аналогичный функционал на языке Python.

\clearpage