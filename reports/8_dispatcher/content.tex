\section{Цель работы}
Изучить механизмы создания и управления процессами в кооперативном и вытесняющим режиме; изучить внутреннее устройство организации кооперативной и вытесняющей диспетчеризаций. С помощью примитивных средств диспетчеризации реализовать решение задачи из варианта для микроконтроллеров семейства AVR.
\clearpage


\section{Теоретические сведения}
\textbf{Диспетчеризация процессора} — предоставление всем процессам в системе по очереди в определенном порядке квантов процессорного времени.

Главной целью диспетчеризации является \textbf{максимальная и равномерная} загрузка процессора.


Работа любого процесса в системе представляется как последовательность чередований фаз активности процессора и активности ввода-вывода. Частота периодов активности процессора обратно пропорциональна их длительности.

\textbf{Операционная система} — это комплекс программ, предназначенных для управления ресурсами компьютера и организации взаимодействия с пользователем. 
Операционная система выполняет следующие основные функции, связанные с управлением задачами:
\begin{itemize}
    \item создание и удаление задач;
    \item планирование процессов и диспетчеризация задач;
    \item синхронизация задач, обеспечение их средствами коммуникации.
\end{itemize}

\textbf{Планировщик} — компонента ОС, планирующая выделение квантов времени процессам по определенной стратегии. Различаются стратегии с прерыванием процессов (\textbf{вытесняющие}) (когда при вводе нового более короткого или более приоритетного процесса в систему текущий процесс прерывается) и без прерывания процессов (\textbf{кооперативные}).

\textbf{Диспетчер} — компонента ОС, выполняющая переключение процессора с одного процесса на другой. Время, которое на это требуется, называется скрытой активностью (латентностью) диспетчера и должно быть минимизировано.

\textbf{Диспетчеризация} — задача динамического (краткосрочного) планирования процессов для наиболее эффективного распределения ресурсов, возникающих практически при каждом событии.


Основные критерии диспетчеризации:
\begin{enumerate}
    \item Максимизация использования процессора;
    \item Максимизация пропускной способности системы;
    \item Минимизация среднего времени обработки одного процесса;
    \item Минимизация среднего времени ожидания одним процессом;
    \item Минимизация среднего времени ответа системы;
    \item Равномерность загрузки процессора;
\end{enumerate}

\subsection{Классификация диспетчеров по стратегии обслуживания}

\begin{itemize}
    \item Бесприоритетное обслуживание. Выбор задачи производится в некотором заранее установленном порядке без учета их относительной важности и времени обслуживания.
    \item Приоритетное обслуживание. При обслуживании отдельных задач, задачам предоставляется преимущественное право попасть в состояние исполнения.
\end{itemize}

Приоритет, присвоенный задаче, может быть постоянным или изменяться в процессе её решения.

\subsection{Классификация по способу распределения процессорного времени}

\begin{itemize}
    \item \textbf{Диспетчеризация без перераспределения процессорного времени}, то есть невытесняющая многозадачность (non-preemptive multitasking, кооперативная диспетчеризация) — способ диспетчеризации процессов, при котором активный процесс выполняется до своего завершения. Дисциплины обслуживания FCFS, SJN, SRT относятся к невытесняющим.
    \item \textbf{Диспетчеризация с перераспределением процессорного времени} (вытесняющая многозадачность, preemptive multitasking) — способ, при котором решение о переключении процессора принимается диспетчером задач. Механизм диспетчеризации задач целиком сосредоточен в операционной системе, и программист может писать свое приложение, не заботясь о том, как оно будет выполняться параллельно с другими задачами. При этом операционная система выполняет следующие функции:
    \begin{itemize}
        \item определяет момент снятия с выполнения текущей задачи, сохраняет её контекст в дескрипторе задачи (или в отведенном сегменте памяти)
        \item выбирает из очереди готовых задач следующую и запускает её на выполнение, предварительно загрузив её контекст
    \end{itemize}
    
    Дисциплина RR и многие другие, построенные на её основе, относятся к вытесняющим.
    Число переключений контекста с процесса на процесс возрастает с уменьшением выделяемого кванта времени. 
    Для обработки процессов различных классов и приоритетов (например, пакетных и интерактивных) ОС создает многоуровневые аналитические очереди процессов, каждая из которых обслуживается по различным стратегиям и предоставляет процессам кванты времени различного размера. Процесс может быть переведен из одной очереди в другую.
\end{itemize}

\subsection{Стратегии диспетчеризации}
\subsubsection{Стратегия «в порядке живой очереди»}
First Come First Served (FCFS) — предоставление ресурсов процессам в порядке их ввода в систему независимо от длительности. Время ожидания может оказаться большим, особенно если первым в систему вводится более длительный процесс (эффект сопровождения).

Образуются две очереди: одна из новых задач, а вторая – из ранее выполнявшихся, но попавших в состояние ожидания (рисунок 1). Это позволяет по возможности заканчивать вычисления в порядке их появления. Эта дисциплина обслуживания не требует внешнего вмешательства в ход вычислений, при ней не происходит перераспределение процессорного времени. 

\textbf{Достоинства}: простота реализации и малые расходы ресурсов на формирование очереди задач.

\textbf{Недостатки}: при увеличении загрузки вычислительной системы растет и среднее время ожидания обслуживания, причем короткие задания вынуждены ожидать столько же, сколько и трудоёмкие. Избежать этого недостатка позволяют дисциплины SJN и SRT.

\image{1-1.jpg}{Стратегия First Come First Served}{0.7}

\subsubsection{Стратегия «первый с кратчайшими сроками выполнения работы / следующий с кратчайшим заданием»}
Shortest Job First (SJF) / Shortest Job Next (SJN) — дисциплина планирования без переключения, согласно которой следующим для выполнения выбирается ожидающий процесс с наименьшим временем выполнения — SRTF (Shortest-Remaining-Time-First). Данная стратегия обеспечивает минимальное среднее время ожидания процессов и является кооперативной стратегией.

\subsubsection{Стратегия «следующий по наименьшему остающемуся времени»}
Shortest remaining time next / Shortest remaining time first, SRTN/SRTF — вытесняющая версия стратегии SJN, где процессор выделяется для задачи, у которой время ближе всего к завершению (оставшееся время). Применяется в системах с разделением времени. 

Метод экспоненциального усреднения позволяет вычислить предсказываемую длину следующего периода активности по фактическим и предсказанным длинам предыдущих периодов активности.
Оставшееся время — это разность между временем, запрошенным пользователем (временем выполнения), и временем, которое процесс уже получил и которое измеряется системой с помощью аппаратного таймера. По принципу SRTN/SRTF первым всегда выполняется процесс, имеющий минимальное оценочное время до завершения, причем с учетом новых поступающих процессов. Если в соответствии с алгоритмом SPN процесс, запущенный в работу, выполняется до своего завершения, то по алгоритму SRT процесс может быть прерван при поступлении нового процесса, имеющего более короткое оценочное время работы. Чтобы механизм SRT был эффективным, нужны достаточно точные оценки будущего.

Механизм SRT характеризуется более высокими накладными расходами по сравнению с SPN, так как должен следить за текущим временем обслуживания выполняющегося задания и обрабатывать возникающи­е прерывания. Поступающие в систему небольшие процессы будут выполняться почти немедленно. Однако более длительные процессы будут иметь даже большее среднее время ожидания и большую дисперсию времени ожидания, чем в случае SPN.

Реализация принципа SRT требует, чтобы­ регистрировались истекшие временные интервалы обслуживания задач, а это при­вод­ит к увеличению накладных расходов. Теоретически алгоритм SRT обеспечивает минимальные времена ожидания. Однако из­-за издержек на переключения может оказаться так, что в определенных ситуациях в действительности лучшие показатели будет иметь SPN.

\subsubsection{Стратегия «следующий с наибольшим относительным временем ответа»}
Highest Response Ratio Next, HRRN — стратегия диспетчеризации без переключения, согласно которой приоритет каждого процесса является не только функцией времени выполнения этого процесса, но также времени, затраченного процессом на ожидание выполнения. После того, как процесс получает в свое распоряжение процессор, он выполняется до завершения. Приоритеты при дисциплине HRRN­ вычисляются по формуле:

\textbf{Приоритет = (время ожидания + время выполнения) / время выполнения.}

Поскольку время выполнения находится в знаменателе, предпочтение будет оказываться более коротким процессам. Однако, поскольку в числителе имеется время ожидания, более длинные процессы, которые уже довольно долго ждут, будут также получать определенное предпочтение.

Алгоритм компенсирует некоторые из недостатков SPN, например, чрезмерную задержку в обслуживании длинных процессов и чрезмерно быстрый отклик на новые короткие задачи.

\subsubsection{Стратегия «Round Robin»}
Стратегия Round Robin предоставляет всем процессам по очереди одинаковые кванты времени процессора (рисунок 2). Квант времени не должен быть слишком мал, иначе накладные расходы на переключение процессов оказываются сравнимыми с полезным временем процессора. Стратегия RR обеспечивает лучшее время ответа, чем SJF, но худшее время оборота.

\image{1-2.jpg}{Стратегия Round Robin}{0.7}

\subsubsection{Стратегия диспетчеризации по приоритету}
Стратегия диспетчеризации по приоритету предоставляет первым ресурсы процессора более высокоприоритетному процессу. Чтобы избежать ситуации "голодания", ОС постепенно повышает приоритеты процессов, длительное время находящихся в системе.
\clearpage



\section{Ход работы}

\subsection{Компиляция}
Рассмотрим реализацию программы. Разработка и отладка полностью реализованы на ОС \texttt{Linux} под архитектуру \texttt{atmega88} с помощью инструмента с открытым исходным кодом \texttt{simavr}, библиотеки \texttt{libxc} (см. Список использованных источников) и предоставленной реализации \texttt{SimpleDispatcher} \cite{libxc} \cite{simavr}.

Команды для компиляции решения представлены в листинге 1.

\begin{lstlisting}[language=bash, caption={Команды для компиляции}, numbers=none, lineskip={0pt}]
avr-gcc -I/home/sthussky/libxc/include/ -Wall -mmcu=atmega88  -c -x c -funsigned-char -funsigned-bitfields -Og -ffunction-sections -fdata-sections -fpack-struct -fshort-enums -g2 -Wall -MD -MP -MF -c main.c -o main.o
avr-gcc -I/home/sthussky/libxc/include/ -Wall -mmcu=atmega88  -c -x c -funsigned-char -funsigned-bitfields -Og -ffunction-sections -fdata-sections -fpack-struct -fshort-enums -g2 -Wall -MD -MP -MF -c rtos.c -o rtos.o
avr-gcc -I/home/sthussky/libxc/include/ -Wall -mmcu=atmega88  -c -x c -funsigned-char -funsigned-bitfields -Og -ffunction-sections -fdata-sections -fpack-struct -fshort-enums -g2 -Wall -MD -MP -MF -c software_RTC.c -o srtc.o -fcommon
avr-gcc  -o dispatch88.elf rtos.o srtc.o main.o -lm -mmcu=atmega88 -funsigned-char -funsigned-bitfields -Wl,--start-group -Wl,-lm  -Wl,--end-group -Wl,--gc-sections -Og -ffunction-sections -fdata-sections -fpack-struct -fshort-enums  -Wl,-Map="simpleDispatcher.map" -fcommon
\end{lstlisting}

\subsection{Организация вывода}

Вывод программы реализован как симуляция взаимодействия с \linebreak UART-интерфейсом. Это позволяет в реальном времени отслеживать состояние программы, не пользуясь средствами отладки. Настройка взаимодействия с интерфейсом приведена на рисунке 3.

\image{21.png}{Настройка взаимодействия с симуляционным UART-интерфейсом}{0.7}

\subsection{Организация ввода}

Согласно требованиям к лабораторной работе, файл с входными данными реализован как массив во flash-памяти микроконтроллера (листинг 2). Чтение из него реализовано функцией \texttt{pgm\_read\_byte()}. Подобные инициализация и чтение возможны благодаря библиотеке \texttt{avr/prgmspace.h}

\begin{lstlisting}[language=c, caption={Массив входных данных}, numbers=none, lineskip={0pt}]
const char data[255] PROGMEM = 
"tW#B5^hknk94lD*!8NwH6DOVhs%od(Aa6D7[LOq4t@(jdd<.VeY7#N1W6l&5[l1QFQbRw5#Nv1@
Fd6k8Qzl43@00W$p5W9%/4W8[{ydhTXNF<{1e#Qx3y9%/st.9)lIxUje4AjH=w!t1+p79AWSk3}{
W6Bb_3[@>tzqff3$c2vL/m_WXt-I4yj-&Qgd}**nbstP1R$9e63G>u#3tJU99r0/q3548^jjR3u1
%t]D*zr66X^47MsK2c8.O1[";
\end{lstlisting}


\subsection{Результат работы программы}

Результатом работы программы является полностью работоспособная программа на основе кооперативного диспетчера. При корректно указанных в тексте программы входных данных она выдает верный результат (рисунок 4). Диаграмма Ганта приведена на рисунке 5, блок-схема — на рисунке 6.

\image{22.png}{Корректная работа программы}{1}

\image{31.png}{Диаграмма}{1}

\image{33.png}{Блок-схема}{0.3}


\subsection{Дополнительные пункты}

После изучения средства симуляции \texttt{simavr} реализовано завершение программы с помощью двух команд — \texttt{DISABLE\_INTERRUPT} и \texttt{sleep\_cpu} (библиотека \linebreak \texttt{avr/sleep.h}). Здесь используется особенность \texttt{simavr} — симуляция прекращается при вечном (никак не прерываемом) \texttt{sleep\_mode} процессора.

Для получения критерия завершения в модуле \texttt{RTOS} реализован счетчик задач — \texttt{volatile static uint8\_t} переменная, инкрементируемая при вызове \texttt{RTOS\_SetTask} и декрементируемая при вызове \texttt{RTOS\_DeleteTask}. Также реализован интерфейс для нее — функция \texttt{RTOS\_CHECK\_ACTIVE()}, возвращающая значение 0 при условии наличия лишь одной активной задачи (взведенного таймера). Логика в \texttt{main.c} принимает вид:

\image{23.png}{Завершение программы}{1}

В качестве дополнительного задания с помощью открытых источников реализовано простое подобие вытесняющего диспетчера без использования \linebreak \texttt{DisplacingDispatcher} \cite{qsnake}. Результат работы реализации представлен на рисунке 8:

\image{24.png}{Независимая реализация вытесняющей логики}{1}
\clearpage

Диаграмма Ганта приведена на рисунке 9.

\image{32.png}{Диаграмма вытесняющего диспетчера}{1}

\FloatBarrier
\clearpage

\section{Выводы о проделанной работе}
В рамках данной работы изучены механизмы создания и управления процессами в кооперативном и вытесняющим режиме; изучено внутреннее устройство организации кооперативной и вытесняющей диспетчеризаций. С помощью примитивных средств диспетчеризации реализовано решение задачи из варианта для микроконтроллеров семейства AVR. Выполнен ряд дополнительных заданий, связанных с улучшением UX при разработке под AVR. Изучены \texttt{opensource} инструменты, полезные при такой разработке.

\clearpage