\section{Цель работы}
Познакомиться с архитектурой программ на основе конечных автоматов и принципом реализации алгоритма устройства на основе конечных автоматов. Реализовать логику работы (алгоритм) устройства «Вендинговый автомат» на языке С.



\section{Ход работы}

\subsection{Автомат с одним видом товара}

Реализуем алгоритм работы автомата с одним видом товара — напитком за \textbf{9 рублей}.
\begin{itemize}
    \item Начальное состояние — 0. В автомате нет денег. Автомат ожидает внесения монет.
    \item Вносится монета — 1, 2, 5 или 10 рублей. В зависимости от внесённой суммы автомат переходит в следующее состояние, определяемое по таблице переходов (Таблица 1).
    \item В случае, если сумма денег в автомате больше или равна 9 рублей, автомат выдаёт напиток и сдачу и переходит в состояние 0.
    \item В случае, если сумма денег меньше 9, ожидается следующее внесение монеты.
\end{itemize}

Таблица переходов построена по следующему принципу: в первой колонке указано текущее состояние (количество рублей в автомате), во второй колонке — монета, полученная автоматом, в третьей колонке — следующее состояние. В следующих четырёх колонках указан выходной алфавит автомата. Если в колонке стоит единица, то такую сдачу следует выдать.

\begin{table}[]
\caption{Таблица переходов для автомата с одним видом товаров}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
State & Insert & Nextstate & Change 1 & Change 2 & Change 2 2 & Change 5 \\ \hline
0     & 1      & 1         & 0        & 0        & 0          & 0        \\ \hline
0     & 2      & 2         & 0        & 0        & 0          & 0        \\ \hline
0     & 5      & 5         & 0        & 0        & 0          & 0        \\ \hline
0     & 10     & 0         & 1        & 0        & 0          & 0        \\ \hline
1     & 1      & 2         & 0        & 0        & 0          & 0        \\ \hline
1     & 2      & 3         & 0        & 0        & 0          & 0        \\ \hline
1     & 5      & 6         & 0        & 0        & 0          & 0        \\ \hline
1     & 10     & 0         & 0        & 1        & 0          & 0        \\ \hline
2     & 1      & 3         & 0        & 0        & 0          & 0        \\ \hline
2     & 2      & 4         & 0        & 0        & 0          & 0        \\ \hline
2     & 5      & 7         & 0        & 0        & 0          & 0        \\ \hline
2     & 10     & 0         & 1        & 1        & 0          & 0        \\ \hline
3     & 1      & 4         & 0        & 0        & 0          & 0        \\ \hline
3     & 2      & 5         & 0        & 0        & 0          & 0        \\ \hline
3     & 5      & 8         & 0        & 0        & 0          & 0        \\ \hline
3     & 10     & 0         & 0        & 0        & 1          & 0        \\ \hline
4     & 1      & 5         & 0        & 0        & 0          & 0        \\ \hline
4     & 2      & 6         & 0        & 0        & 0          & 0        \\ \hline
4     & 5      & 0         & 0        & 0        & 0          & 0        \\ \hline
4     & 10     & 0         & 0        & 0        & 0          & 1        \\ \hline
5     & 1      & 6         & 0        & 0        & 0          & 0        \\ \hline
5     & 2      & 7         & 0        & 0        & 0          & 0        \\ \hline
5     & 5      & 0         & 1        & 0        & 0          & 0        \\ \hline
5     & 10     & 0         & 1        & 0        & 0          & 1        \\ \hline
6     & 1      & 7         & 0        & 0        & 0          & 0        \\ \hline
6     & 2      & 8         & 0        & 0        & 0          & 0        \\ \hline
6     & 5      & 0         & 0        & 1        & 0          & 0        \\ \hline
6     & 10     & 0         & 0        & 1        & 0          & 1        \\ \hline
7     & 1      & 8         & 0        & 0        & 0          & 0        \\ \hline
7     & 2      & 0         & 1        & 0        & 0          & 0        \\ \hline
7     & 5      & 0         & 1        & 1        & 0          & 0        \\ \hline
7     & 10     & 0         & 1        & 1        & 0          & 1        \\ \hline
8     & 1      & 0         & 0        & 0        & 0          & 0        \\ \hline
8     & 2      & 0         & 1        & 0        & 0          & 0        \\ \hline
8     & 5      & 0         & 0        & 0        & 1          & 0        \\ \hline
8     & 10     & 0         & 0        & 0        & 1          & 1        \\ \hline
\end{tabular}
\end{table}




\image{12.png}{Выделение памяти с помощью \texttt{malloc}}{1}

После вызова \texttt{malloc} в регистр EAX сохраняется адрес выделенной ячейки памяти. На рисунке 3 видно, что этот участок памяти заполнен случайными значениями.
\image{13.png}{Memory dump}{1}
\FloatBarrier


\subsection{Обработка команды в fgets}
В консоль введём слово \texttt{open} для открытия файла. На рисунке 4 видно, что введённое значение было записано в ячейку памяти.

\image{21.png}{Содержимое памяти}{1}
\FloatBarrier


\subsection{Вызов API-функции CreateFile}
Далее вызывается функция \texttt{CreateFileA}. На рисунке 5 приведён нужный фрагмент библиотеки \texttt{kernel32.dll}.
\image{31.png}{Остановка на функции CreateFileA}{1}

На рисунке 6 видно, что в стеке сохранены аргументы функции, например, название файла (\texttt{AlekseyShadrunov.txt}). 
\image{32.png}{Стек}{1}

После вызова API-функции \texttt{CreateFileA} можно увидеть, что в EAX записано
значение \texttt{0xE0}. Это файловый дескриптор или хэндл открытого файла (Рисунок 7). 
\image{34.png}{Хэндл открытого файла}{1}

Этот же хэндл можно пронаблюдать в Process Hacker (Рисунок 8). 
\image{35.png}{Хэндл в Process Hacker}{1}
\FloatBarrier



\subsection{Вызов API-функции WriteFile}
Вводим в консоль команду \texttt{write} для записи строки в файл. На рисунке 9 показано состояние системы перед вызовом функции \texttt{WriteFile}. Все аргументы записаны в стек: хэндл файла (104), буфер со строкой, количество байт для записи (0xC, то есть 13) и ещё два аргумента. 
\image{44.png}{Аргументы в стеке}{1}

На рисунке 10 видно тело функции \texttt{WriteFile}, а также строка для записи, которая находится в дампе памяти. На рисунке 11 — возвращаемое значение 1 (в регистре EAX), что соответствует успешному выполнению функции.
\image{42.png}{Дамп памяти со строкой}{1}
\image{43.png}{Возвращаемое значение 1}{1}
\FloatBarrier


\subsection{Вызов API-функции ReadFile}
Далее считываем из файла с помощью функции \texttt{ReadFile}. Аргументы функции: хэндл (0x100), адрес выходного буфера (0xDC0F60), количество байт для чтения (0xC) и ещё два опциональных аргумента (Рисунок 12). Аргументы записываются в стек перед вызовом функции.
\image{51.png}{Аргументы в стеке}{1}

После вызова функции по адресу выходного буфера содержится строка из файла (Рисунок 13)
\image{53.png}{Строка в памяти}{1}
\FloatBarrier



\subsection{Добавить аргументы к командам}
С помощью ввода в консоль реализовано использование аргументов для задания параметров программы. Для открытия файлов можно задать имя файла, для записи можно задать хэндл и записываемое значение, для чтения можно задать хэндл, для закрытия — тоже хэндл. Для удобства работы пользователя хэндл выводится и вводится в виде десятичного числа. Примеры работы программы представлены на рисунках 14-18. Листинг кода содержится в приложении A. 

\image{61.png}{Открытие файла: вводим название файла, получаем хэндл в виде числа (252)}{0.8}
\image{62.png}{Этот хэндл в Process Hacker (0xFC = 252)}{1}
\image{63.png}{Команда \texttt{запись}: вводим хэндл файла, значение для записи}{0.8}
\image{64.png}{Команда \texttt{чтение}: вводим хэндл файла, программа выводит содержимое}{0.8}
\image{65.png}{Команда \texttt{закрыть}: видно, что хэндл исчез из Process Hacker}{1}
\FloatBarrier


\subsection{Найти утечку ресурсов в программе}
Утечка памяти в исходном файле связана с тем, как обрабатываются хэндлеры открытого файла. Видно, что для хранения хэндла используется переменная \texttt{HANDLE hFile}, которая создаётся при запуске программы. Далее при вводе команды \texttt{открыть} в эту переменную присваивается хэндл на открытый файл. Если ввести команду \texttt{открыть} ещё раз, то предыдущее значение хэндла будет перезаписано. Это значит, что закрыть предыдущий хэндл и освободить память невозможно. 

Есть несколько путей исправления этой утечки: можно создать массив хэндлов и записывать каждый следующий файл в массив, можно закрывать старый файл перед открытием нового файла. Наконец, можно запрещать открытие файла, если хэндл уже определён (и файл уже открыт). Реализация этого способа приведена на листинге 1. Результат работы программы — на рисунке 19.

\begin{lstlisting}[language=c, numbers=none, caption={Фрагмент функции main}]
else if ( strncasecmp(command, "open", strlen(command)) == 0 )
{
    if ( hFile == INVALID_HANDLE_VALUE )
    {
        ret = LabOpenFile(chFileName, &hFile, &len);
    } 
    else 
    {
        printf("handle already defined. can't open file again! \n");
    }
}
\end{lstlisting}

\image{71.png}{Повторная команда открыть не работает}{1}
\FloatBarrier



\clearpage






\clearpage



\section{Выводы о проделанной работе}
В рамках данной работы получены знания: о принципах работы ЭВМ, об особенностях архитектуры компьютера фон Неймана и x86/x64 и о работе с объектами в ОС Windows.
В рамках данной работы получены навыки: анализ программ с использованием отладчика уровня ассемблера и отладка и поиск проблем с использованием средств Sysinternals.