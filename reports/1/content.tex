\section{Цели работы}
Реализовать программу, выполняющую ввод, сериализацию в текстовый или бинарный файл, а также десериализацию и вывод в консоль пользователю информации об аэропорте.



\section{Ход работы}
В ходе работы я написал программу, реализующую необходимый функционал, на языке C.
\subsection{Структура программы}
\subsubsection{main}
Работа программы начианется с функции \texttt{main}. Функция принимает на вход аргументы из командной стоки: флаги, выбирающие режим работы программы, и путь к файлу. Допустимые флаги:

\begin{itemize}
    \item \verb|-e| используется для включения режима кодирования;
    \item \verb|-d| используется для включения режима декодирования;
    \item флаг \verb|-t| позволяет использовать текстовый файл для хранения структуры.
\end{itemize}

Примеры запуска программы:
\begin{lstlisting}[language=bash, numbers=none]
./hw1 -e file.bin  # encrypt to file.bin
./hw1 -t file.bin  # read from file.bin
./hw1 -et file.txt  # use text file file.txt
./hw1 -et file.txt
\end{lstlisting}

Разберем последовательность работы.

\begin{itemize}
    \item Сначала функция проверяет число переданных аргументов (должно быть три или четыре, иначе исключение).
    \item Далее функция определяет режим работы. Обязательно должно быть указано, кодирование или декодирование следует выполнять. Также определяется режим работы с файлом. Cохраняется путь к файлу.
    \item Если происходит кодирование, то далее программа вызывает функцию \\ \verb|get_data_from_user| для ввода данных от пользователя.
    \item Выделяется динамическая память для хранения преобразованных данных перед записью в файл.
    \item Вызывается функция \verb|process|, которая копирует байты из структуры в буфер для преобразованных данных, применяя к каждому байту функцию \verb|xor_byte|.
    \item Далее буфер записывается в файл. Если файл текстовый, то каждое значение байта заменяется соответствующим строковым представлением по таблице замен. Если же файл бинарный, запись производится непосредственно.
    \item Если выбран режим декодирования, то последовательность действий обратная: сначала создаётся пустая структура и буфер для ввода информации из файла. Затем из текстового файла считываются единицы и нули для образования байта, после чего конвертируются в \verb|char|; из бинарного файла чтение происходит напрямую в буфер. Далее буфер подаётся на вход функции \verb|process|, которая расшифровывает и записывает данные в структуру. Результат выводится на экран.
    \item В конце все ресурсы освобождаются.
\end{itemize}


\subsubsection{str2char}
Функция переводит cтроковую двоичную запись байта в \verb|char|.

\subsubsection{print\_help}
Печатает справку о том, как пользоваться программой (какие аргументы допустимы).

\subsubsection{AirportEntry}
Структура для хранения данных об аэропорте. Состоит из двух полей:
\begin{itemize}
    \item \texttt{char name[128]} — имя аэропорта, максимальная длина 127 символов.
    \item \texttt{char letters[3]} — буквенный код аэропорта.
\end{itemize}

\subsubsection{AirportUnion}
Объединение для доступа к данным об аэропорте побайтно. Состоит из двух полей:
\begin{itemize}
    \item \texttt{struct AirportEntry ent} — структура;
    \item \texttt{char arr[sizeof(struct AirportEntry) / sizeof(char)]} — байтовый массив, используется для байтового доступа к данным структуры.
\end{itemize}

\subsubsection{xor\_byte}
Функция принимает на вход \verb|char|, к которому применяет шифрующее или дешефрующее преобразование — побитовое исключающее ИЛИ с числом \verb|01010101|.

\subsubsection{process}
Функция принимает на вход указатели на два буфера (массива байт) – входной и выходной, их размеры, а также функцию обратного вызова и записывает результат применения функции к элементам входного буфера на соответствующие позиции выходного буфера.



\subsection{Работа программы}
Продемонстрируем различные режимы работы программы.

\subsubsection{-e}
Здесь мы ввели данные об аэропорте Домодедово и сохранили их в файл file.bin (Рисунок 1):

\image{1.png}{Работа в режиме бинарного шифрования}{0.83}
\FloatBarrier


\subsubsection{-d}
Расшифруем данные об аэропорте Домодедово из файла file.bin (Рисунок 2):

\image{2.png}{Работа в режиме бинарного расшифрования}{0.81}
\FloatBarrier


\subsubsection{-et}
Зашифруем данные об аэропорте Внуково в текстовый файл file.txt. Содержимое файла показано на экране (Рисунок 3):

\image{3.png}{Работа в режиме текстового зашифрования}{0.81}
\FloatBarrier

\subsubsection{-d}
Расшифруем данные из текстового файла file.txt (Рисунок 4):

\image{4.png}{Работа в режиме текстового расшифрования}{0.81}
\FloatBarrier



\subsection{Исключения}

\subsubsection{Пользовательский ввод}
Пользовательский ввод реализован надёжно: подающаяся на вход последовательность считывается в динамическую память до первого символа перевода строки/конца файла, после чего символы, выходящие за границы диапазона структуры, обрезаются. Далее считываются три символа для использования в качестве кода аэропорта. На рисунке 5 показана работа в случае длинной последовательности:

\image{5.png}{Длинная входная последовательность}{0.85}
\FloatBarrier

Таким образом, любой ввод корректно обрабатывается.


\subsubsection{Нет доступа к файлу при чтении}
Проверим, что будет, если заставить программу произвести расшифрование несуществующего файла (Рисунок 6):

\image{6.png}{Нет файла}{0.83}
\FloatBarrier

Перед открытием на чтение проверяется, что файл существует, в противном случае пользователю выводится сообщение об ошибке.

\subsubsection{Неправильные аргументы}
Если нет нужных аргументов, программа не будет работать (Рисунок 7):

\image{7.png}{Неправильные аргументы}{0.83}
\FloatBarrier

Перед открытием на чтение проверяется, что файл существует, в противном случае пользователю выводится сообщение об ошибке.

Также в программе есть обработка ещё некоторых исключений, но они не возникают.



\clearpage



\section{Выводы о проделанной работе}
В ходе работы я реализовал программу, выполняющую ввод, сериализацию в текстовый или бинарный файл, а также десериализацию и вывод в консоль пользователю информации об аэропорте. Для переключения режимов работы используются аргументы командной строки.